---
title: 重绘重排
date: 2018-08-28 09:44:35
tags: 性能优化
description: 梳理渲染树构建、布局绘制以及重绘重排
categories: 性能优化
keywords: 重绘重排、渲染树构建布局和绘制
---

> 了解重绘重排前，应当先了解浏览器绘制页面的过程

## 渲染过程
> - 解析HTML文件，生成DOM树
> - 解析CSS文件，生成CSSOM
> - 结合DOM和CSSOM，生成渲染树(包含页面所有可见节点及其计算样式)
> - 根据渲染树生成布局（layout）(将渲染树的所有节点进行平面合成，各个节点在设备视口的确切位置及大小，即获得每个节点的几何信息)
> - 绘制(将布局（各个节点）绘制在屏幕上)
<div align="center">
  <img src="/teresa/images/render.png" alt="渲染过程">
</div>

### 生成渲染树过程：

> - 从DOM树的根节点进行遍历每个可见的节点
>   - 某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。
>   - 某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，节点上设置了“display: none”属性。
> - 为每个节点找到他适配的CSSOM，并应用
> - 发射该节点及其内容和计算样式

### 布局（自动重排）
> - 浏览器从渲染树的根节点开始进行遍历
> - 布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素


### 绘制或栅格化

我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素，这一步就是绘制。

执行渲染树构建、布局和绘制所需的时间将取决于文档大小、应用的样式，以及运行文档的设备：文档越大，浏览器需要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如，单色的绘制开销“较小”，而阴影的计算和渲染开销则要“大得多”）。

## 重绘重排
当改变DOM和CSS时将会引起重绘重排；
- 当影响了页面的布局，元素的几何属性的时候会引起重排（比如字体大小改变，元素位置的改变）
- 除了上面以外的（比如颜色的变话）会引起重绘

重排一定会重绘，而重绘不一定会重排

### 减少重绘（repaint）重排（reflow）

- 应尽量减少更改DOM和CSS的次数，通过更改class来改变样式
- 将需要修改DOM脱离文档流
  - 隐藏元素，修改，重新显示。
  - 使用文档片断（document fragment），在当前DOM外构建一个子树，再把它插入文档中。
  - 把原始元素拷贝到脱离文档的节点中，修改后在把原始元素替换掉。
- `transform`和`opacity`不会触发重绘,应多使用这两个属性，减少`position`的使用
- [https://csstriggers.com/](https://csstriggers.com/) 这里统计了各个css属性是否会触发重绘重排

> 参考链接：[网页性能管理详解](http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html)
> 
> 参考链接：[渲染树构建、布局及绘制](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn)